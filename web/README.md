# web

### web标准

web标准不是某一个标准，而是一系列标准的集合。为解决网上应用中不同平台，技术和开发者带来的不兼容问题，保障网上信息的顺利和完整流通，万维网联盟（W3C）制定了一系列标准并督促网上应用开发者和内容提供者遵循这些标准，标准的内容包括使用语言的规范，开发中使用的导则和解释引擎的行为等等。
网页主要有三部分组成，结构，表现和行为。对应的标准也主要分为三方面：

1. 结构化标准语言 HTML
2. 表现标准语言 CSS
3. 行为标准 文档对象模型DOM,ECMAScript

实际编程中也有一些代码规范：
1. html标签字母要小写
2. 标签要闭合
3. 尽量使用外链css和js,符合结构，表现，行为的分离。
4. 尽量少的使用行内样式表

结构，表现，行为分离的优点：
1. 易于维护，只需更改CSS文件，就可以改变整站的样式
2. 页面响应快：HTML文档体积变小，响应时间短
3. 可访问性：语义化的HTML（结构和表现相分离的HTML）编写的网页文件，更容易被屏幕阅读器识别
4. 设备兼容性：不同的样式表可以让网页在不同的设备上呈现不同的样式
5. 搜索引擎：语义化的HTML能更容易被搜索引擎解析，提升排名

### 什么是一个好的web站点

1. 可用性， 产品是否容易上手，用户体验如何，用户体验才是企业的核心竞争力
2. 可维护性， 出现问题是否能够迅速定位，代码可读性要好，毕竟不是一个人在做产品
3. 可访问性， 语义化的HTML,更容易被屏幕阅读器识别
4. 符合web标准， 结构，表型，行为分离


### 浏览器的缓存策略
    
浏览器缓存，也是客户端缓存，是网页性能优化很重要的一个点。

1. 浏览器缓存的基本认识，浏览器缓存分为强缓存和协商缓存
    1. 浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；
    2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；
    3. 强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。
    4. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

2. 强缓存

    当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。

    Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：

    1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。
    2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；
    3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。
    4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。
    5. Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果

    Cache-Control是http1.1的时候，提出了一个新的header，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：

    1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header。
    2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；
    3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。
    4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。
    5. Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。

    这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。

2. 协商缓存

    当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。

    【Last-Modified，If-Modified-Since】的控制缓存的原理是：

    1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间
    2. 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值
    3. 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变
    4. 浏览器收到304的响应后，就会从缓存中加载资源
    5. 【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。

    【ETag、If-None-Match】的控制缓存的原理是：

    1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系。
    2. 浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值
    3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化
    4. 浏览器收到304的响应后，就会从缓存中加载资源。

3. 合适的缓存策略
    
    1. 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
    2. 强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control
    3. 强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。
    4. 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新

4. 浏览器行为对缓存的影响
    1. 地址栏回车,页面链接跳转,新窗口打开,前进、后退 都会经过强缓存和协商缓存；
    2. 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
    3. 当f5刷新网页时，跳过强缓存，但是会检查协商缓存
    4. 使用浏览器的隐私模式开发，跳过强缓存和协商缓存
    5. 如果用的是chrome，可以f12在network那里把强缓存给禁掉

### CDN

CDN的全称是Content Delivery Network, 及内容分发网络，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快，更可靠的地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。

CDN本身是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用CDN实质上就是让CDN作为网站的门面，用户访问到的是CDN服务器，而不是直接访问到网站。由于CDN内部对TCP的优化、对静态资源的缓存、预取，加上用户访问CDN时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。

### HTTPS

HTTPS安全超文本传输协议，它是一个安全通信通道，基于HTTP开发，用于在客户计算机和服务器之间的信息交换。简单来说就是HTTP的安全版，是使用了TLS/SSL加密的HTTP协议

### 网页验证码用处

1. 区分用户是计算机还是人的公共全自动程序，防止恶意破解密码，刷票，论坛灌水等
2. 例如黑客用程序不断暴力破解


